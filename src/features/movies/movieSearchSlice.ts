import { createSlice, PayloadAction } from "@reduxjs/toolkit";
import { RootState } from "../../app/store";
import { MovieSearchState } from "./moviesInterface";
import {
  findNowPlaying,
  findTrendingMovies,
  findMoviesByGenre,
  findMoviesBySearch,
  findMovieDetail,
  findMovieCast,
  findCastDetail,
  findMoviesByActor,
  findRecommendedMovies,
} from "./moviesApi";

const initialState: MovieSearchState = {
  moviesNowPlaying: [],
  moviesTrending: [],
  moviesByGenre: [],
  moviesAction: [],
  moviesAnimation: [],
  moviesComedy: [],
  moviesDrama: [],
  moviesFantasy: [],
  moviesHorror: [],
  moviesRomance: [],
  moviesSciFi: [],
  moviesSearch: [],
  movie: {
    id: "",
    genres: [{ name: "" }],
    homepage: "",
    poster_path: "",
    original_title: "",
    overview: "",
    release_date: "",
    runtime: 0,
    vote_average: 0,
  },
  cast: [
    {
      id: 0,
      name: "",
      original_name: "",
      popularity: 0,
      profile_path: "",
      cast_id: 0,
      character: "",
      credit_id: "",
      order: 0,
    },
  ],
  actor: {
    biography: "",
    birthday: "",
    deathday: "",
    homepage: "",
    id: 0,
    name: "",
    place_of_birth: "",
    popularity: 0,
    profile_path: "",
  },
  recommendations: [],
  moviesWithActor: [],
  status: "idle",
};

export const movieSearchSlice = createSlice({
  name: "movieSearch",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    // Use the PayloadAction type to declare the contents of `action.payload`
    clearSearch: (state, action: PayloadAction<[]>) => {
      state.moviesSearch = action.payload;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      //Nowplaying
      .addCase(findNowPlaying.pending, (state) => {
        state.status = "loading";
      })
      .addCase(findNowPlaying.fulfilled, (state, action) => {
        state.status = "idle";
        state.moviesNowPlaying = action.payload;
      })
      .addCase(findNowPlaying.rejected, (state) => {
        state.status = "failed";
      })
      //findTrendingMovies
      .addCase(findTrendingMovies.pending, (state) => {
        state.status = "loading";
      })
      .addCase(findTrendingMovies.fulfilled, (state, action) => {
        state.status = "idle";
        state.moviesTrending = action.payload;
      })
      .addCase(findTrendingMovies.rejected, (state) => {
        state.status = "failed";
      })
      //findMoviesByGenre
      .addCase(findMoviesByGenre.pending, (state) => {
        state.status = "loading";
      })
      .addCase(findMoviesByGenre.fulfilled, (state, action) => {
        state.status = "idle";
        switch (action.payload.genre) {
          case 28:
            state.moviesAction = action.payload.data;
            break;
          case 16:
            state.moviesAnimation = action.payload.data;
            break;
          case 35:
            state.moviesComedy = action.payload.data;
            break;
          case 18:
            state.moviesDrama = action.payload.data;
            break;
          case 14:
            state.moviesFantasy = action.payload.data;
            break;
          case 27:
            state.moviesHorror = action.payload.data;
            break;
          case 10749:
            state.moviesRomance = action.payload.data;
            break;
          case 878:
            state.moviesSciFi = action.payload.data;
            break;
          default:
            state.moviesByGenre = action.payload.data;
        }
      })
      .addCase(findMoviesByGenre.rejected, (state) => {
        state.status = "failed";
      })
      //findMoviesBySearch
      .addCase(findMoviesBySearch.pending, (state) => {
        state.status = "loading";
      })
      .addCase(findMoviesBySearch.fulfilled, (state, action) => {
        state.status = "idle";
        state.moviesSearch = action.payload;
      })
      .addCase(findMoviesBySearch.rejected, (state) => {
        state.status = "failed";
      })
      // findMovieDetail
      .addCase(findMovieDetail.pending, (state) => {
        state.status = "loading";
      })
      .addCase(findMovieDetail.fulfilled, (state, action) => {
        state.status = "idle";
        state.movie = action.payload;
      })
      .addCase(findMovieDetail.rejected, (state) => {
        state.status = "failed";
      })
      // findMovieCast
      .addCase(findMovieCast.pending, (state) => {
        state.status = "loading";
      })
      .addCase(findMovieCast.fulfilled, (state, action) => {
        state.status = "idle";
        state.cast = action.payload;
      })
      .addCase(findMovieCast.rejected, (state) => {
        state.status = "failed";
      })
      // findCastDetail
      .addCase(findCastDetail.pending, (state) => {
        state.status = "loading";
      })
      .addCase(findCastDetail.fulfilled, (state, action) => {
        state.status = "idle";
        state.actor = action.payload;
      })
      .addCase(findCastDetail.rejected, (state) => {
        state.status = "failed";
      })
      // findMoviesByActor
      .addCase(findMoviesByActor.pending, (state) => {
        state.status = "loading";
      })
      .addCase(findMoviesByActor.fulfilled, (state, action) => {
        state.status = "idle";
        state.moviesWithActor = action.payload;
      })
      .addCase(findMoviesByActor.rejected, (state) => {
        state.status = "failed";
      })
      // findRecommendedMovies
      .addCase(findRecommendedMovies.pending, (state) => {
        state.status = "loading";
      })
      .addCase(findRecommendedMovies.fulfilled, (state, action) => {
        state.status = "idle";
        state.recommendations = action.payload;
      })
      .addCase(findRecommendedMovies.rejected, (state) => {
        state.status = "failed";
      });
  },
});

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectMovie = (state: RootState) => state.movieSearch;

export const { clearSearch } = movieSearchSlice.actions;

export default movieSearchSlice.reducer;
